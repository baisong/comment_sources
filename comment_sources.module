<?php
// $Id$

/**
 * @file
 * Code for Comment Sources module.
 */

/**
 * Includes non-hook functions and helper functions.
 */
ctools_include('api');

/**
 * Includes comment_sources hook implementations for Drupal, Facebook, Disqus.
 */
ctools_include('sources');

/**
 * Implements hook_menu().
 */
function comment_sources_menu() {
  $items = array();
  $items['admin/config/services/comment_sources'] = array(
    'title' => 'Comment Sources',
    'description' => 'Select commenting system(s) to use',
    'access arguments' => array('administer comments and comment settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('comment_sources_admin_settings_form'),
    'file' => 'comment_sources.admin.inc',
  );
  $items['comment_sources/record_comment'] = array(
    'title' => 'Record new comment',
    'description' => 'Record creation of a new comment by a third-party commenting source',
    'access arguments' => array('access content'),
    'page callback' => 'comment_sources_record_comment_ajax',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Gets list of available comment sources.
 *
 * In some cases (fb_social) a module can provide multiple comment sources.
 * If that's the case, provide a callback function to retrieve each comment
 * source associated with that module.
 *
 * @return array $sources
 */
function _comment_sources_sources() {
  // Drupal content style guide: use "sentence caps" for headings and actions.
  // @see http://drupal.org/style-guide/content#headings
  $base_sources = array(
    'comment' => array(
      'description' => t('Drupal comments'),
      'supports_recent_comments' => TRUE,
    ),
    'disqus' => array(
      'description' => t('Disqus comments'),
      'supports_recent_comments' => TRUE,
    ),
    'fb_social' => array(
      'description' => t('Facebook comments'),
      'supports_recent_comments' => FALSE,
      'children_callback' => 'comment_sources_fb_social',
    ),
  );

  // Gets comment sources provided by other modules.
  $other_sources = module_invoke_all("comment_sources");
  $sources = array_merge_recursive($base_sources, $other_sources);
  // Allows other modules to alter the $sources array.
  drupal_alter('comment_sources', $sources);

  return $sources;
}

/**
 * Gets list of the currently enabled comment sources.
 *
 * @return array $enabled_sources
 */
function comment_sources_enabled_sources() {
  $enabled_sources = &drupal_static(__FUNCTION__);
  if (!is_null($enabled_sources)) {
    return $enabled_sources;
  }

  $sources = _comment_sources_sources();
  $enabled_sources = array();

  // Checks to ensure the comment source modules are enabled
  foreach ($sources as $key => $value) {
    if (module_exists($key)) {
      if (isset($value['children_callback'])) {
        $enabled_sources = array_merge($enabled_sources, call_user_func($value['children_callback'], $value));
      }
      else {
        $enabled_sources[$key] = $value;
      }
    }
  }
  return $enabled_sources;
}

/**
 * Gets Facebook Social comment presets
 */
function _comment_sources_preset_fb_social() {
  $presets = array();
  if (function_exists('fb_social_get_presets_by_type')) {
    $presets = fb_social_get_presets_by_type('comments');
  }
  return $presets;
}

/**
 * Gets available comment presets for fb_social.
 *
 * Loops over all comments fb_social presets, and returns an array of comment
 * sources for each, keyed by "fb_social:$preset_name".
 *
 * @param NULL $null
 *   unused @todo remove?
 *
 * @return array $enabled_sources
 */
function comment_sources_fb_social($null = NULL) {
  $enabled_sources = array();

  $presets = _comment_sources_preset_fb_social();

  if (count($presets) > 0) {
    foreach ($presets as $preset) {
      $enabled_sources[join(":", array('fb_social', $preset->name))] = array(
        'description' => $preset->name,
      );
    }
  }

  return $enabled_sources;
}

/**
 * Sets the comment source for this content type, with appropriate options.
 */
function comment_sources_set_nodetype_source($source, $nodetype, $vsite = FALSE) {
  // Returns FALSE if the specified node type is invalid.
  if (!array_key_exists($content_type, node_type_get_types())) {
    return FALSE;
  }

  // Gets a keyed array mapping nodetypes => current comment source.
  $type_settings = comment_sources_type_settings();

  // If a source is specified, validates and prepares to save.
  if (!empty($source)) {
    // Returns FALSE if the specified source is invalid.
    $enabled_sources = comment_sources_enabled_sources();
    if (!array_key_exists($source, $enabled_sources)) {
      return FALSE;
    }
    $type_settings[$content_type] = $source;
  }

  // Otherwise, unsets this content type, disabling comments for the node type.
  else {
    unset($type_settings[$content_type]);
  }

  // Saves changes to static variable and invokes save callbacks.
  comment_sources_save_nodetypes_sources($type_settings);

  return TRUE;
}

/**
 * Gets the comment source for this content type or node, or FALSE if invalid.
 *
 * @param mixed $node_info
 *   Accepts a node object, node type string or nid.
 *
 * @return mixed
 *   One of the available source strings, or FALSE if passed invalid param.
 */
function comment_sources_get_source($node_info) {
  // If this looks like a nodetype string, return the nodetype's source.
  if (is_string($node_info) && !is_numeric($node_info)) {
    $type = $node_info;
    return comment_sources_get_type_setting($type);
  }
  // Otherwise, attempt to load the node if this looks like a node ID.
  if (is_numeric($node_info)) {
    $node_info = node_load($node_info);
  }
  // If we have a node object...
  if (is_object($node_info) && isset($node_info->type)) {
    $node = $node_info;
    // Returns the default source for this node type if the node is new.
    if (!isset($node->nid) || isset($node->is_new)) {
      return comment_sources_get_type_setting($node->type);
    }
    // Otherwise, finds the existing stored comment source for this node.
    return comment_sources_get_source_node($node);
  }
  // Returns FALSE if the $node_info param was invalid.
  return FALSE;
}

/**
 * Gets the comment source for this node type.
 */
function comment_sources_get_type_setting($type) {
  $type_settings = comment_sources_type_settings();
  return isset($type_settings[$type]) ? $type_settings[$type] : '';
}

/**
 * Gets the comment source for this node.
 */
function comment_sources_get_source_node($node) {
  // Returns the first-recorded comment source for this node.
  $results = db_select('comment_sources_comments', 'c')
    ->orderBy('cid', 'ASC')
    ->condition('nid', $node->nid)
    ->fields('c', array('source'))
    ->execute()
    ->fetchAllAssoc('cid');
  foreach ($results as $cid => $record) {
    return $record->source;
  }

  // Otherwise, defaults to this node type's setting if no result was found.
  return comment_sources_get_type_setting($node->type);
}

/**
 * Returns the status (1 or 0) of the active comment source for the given node.
 */
function comment_sources_get_status($node) {
  if (is_object($node) && $node->nid) {
    $nid = $node->nid;
  }
  else if (is_numeric($node)) {
    $nid = $node;
  }
  // Returns the first-recorded comment source for this node.
  $results = db_select('comment_sources_comments', 'c')
    ->orderBy('cid', 'ASC')
    ->condition('nid', $nid)
    ->fields('c', array('status'))
    ->execute()
    ->fetchAllAssoc('cid');
  foreach ($results as $cid => $record) {
    return $record->status;
  }

  // Default: Returns FALSE if no node record was found.
  // The node may not exist, or the node exists but source = "No comments".
  return FALSE;
}

/**
 * Records the comment source and status (1 or 0) for the given node.
 */
function comment_sources_record_node_settings($node, $source, $status, $new = FALSE) {
  // Handles and validates $node param.
  if (is_object($node) && $node->nid) {
    $nid = $node->nid;
  }
  if (is_numeric($node)) {
    $nid = $node;
  }
  if (!$nid) {
    return FALSE;
  }

  if (in_array($source, array('comment', ''))) {
    $success = _comment_sources_record_node_drupal($nid, $source, $status, $new);
  }
  else {
    $success = _comment_sources_record_node_external($nid, $source, $status, $new);
  }

  // Returns TRUE if the drupal_write_record() succeeded.
  return ($success !== FALSE);
}

/**
 * @todo
 */
function _comment_sources_record_node_drupal($nid, $source, $status, $new) {

}

/**
 *
 */
function _comment_sources_record_node_external($nid, $source, $status, $new) {
  // Finds any existing record of this node and this source.
  $record = db_select('comment_sources_comments', 'c')
    ->condition('c.nid', $nid)
    ->condition('c.source', $source)
    ->fields('c', array('nid'))
    ->execute();

  // Makes the data array to write to the database.
  $data = array(
    'nid' => $nid,
    'source' => $source,
    'status' => $status,
  );

  // Updates the existing record or adds a new record.
  if ($record->rowCount() > 0) {
    $success = drupal_write_record('comment_sources_comments', $data, array('nid', 'source'));
  }
  else {
    $success = drupal_write_record('comment_sources_comments', $data);
  }
  return $success;
}

/**
 * Returns if comments have been disabled for this node and source.
 *
 * Additionally, checks if there are no comments from another comment source.
 *
 * Assumes the source is the selected source for the content type.
 *
 * @todo verify logic
 */
function comment_sources_should_display_comments($node, $source) {
//  if (is_numeric($node)) {
//    $node = node_load($node);
//  }
//
//  if ($node && $node->nid) {
//    // Finds any record of this node with this comment source.
//    $results = db_select('comment_sources_comments', 'c')
//      ->condition('nid', $node->nid)
//      ->condition('source', $source)
//      ->fields('c', array('status', 'has_comments'))
//      ->execute()
//      ->fetchAllAssoc('nid');
//
//    // Returns TRUE if the source is status != 0.
//    foreach ($results as $nid => $info) {
//      if ($info['status']) {
//        return TRUE;
//      }
//    }
//  }
//
//  return FALSE;
  $result = TRUE;
  if ($node && $node->nid) {
    $record = db_select('comment_sources_comments', 'c')->condition('c.nid', $node->nid)->fields('c', array('source', 'status', 'has_comments'))->execute();
    foreach ($record as $row) {
      if ($row->source == $source) {
        // Always display if there are comments for the selected source
        if ($row->has_comments) {
          $result = TRUE;
          break;
        }
        // Disable if comments not enabled for the node
        else {
          if (!$row->status) {
            $result = FALSE;
          }
        }
      }
      else {
        // Disable if there are comments for another content type
        if ($row->has_comments) {
          $result = FALSE;
        }
      }
    }
  }
  return $result;
}

/**
 * Checks db if this comment source has any comments for this node.
 *
 * @param mixed $node
 *   Accepts a node object or a node ID
 * @param string $source
 *   A machine name of a comment source.
 *
 * @return bool $has_comments
 *   TRUE only if the node is found and stored with has_comments = 1.
 *
 * Uses drupal_static("comment_sources_has_comments") to store:
 * @code
 * $has_comments = array(
 *   'source1' => array(
 *     '123' => 0,
 *     '234' => 1,
 *     ...
 *   ),
 *   'source2' => array(...),
 * );
 * @endcode
 *
 */
function comment_sources_has_comments($node, $source) {
  // Handles and validates $node param.
  if (is_object($node) && $node->nid) {
    $nid = $node->nid;
  }
  if (is_numeric($node)) {
    $nid = $node;
  }
  if (!$nid) {
    return FALSE;
  }

  // Stores info in a drupal_static variable.
  $has_comments = &drupal_static(__FUNCTION__, array());
  // Quickly returns the already indexed information.
  if (isset($has_comments[$source]) && isset($has_comments[$source][$nid])) {
    return $has_comments[$source][$nid];
  }

  // Otherwise, this function is being invoked for the first time with these
  // params. Builds and returns the information.
  if (!isset($has_comments[$source])) {
    $has_comments[$source] = array();
  }

  // Default value is FALSE if we don't find any information in the database.
  $has_comments[$source][$nid] = FALSE;
  // Gets the "has_comments" value from the database.
  $record = db_select('comment_sources_comments', 'c')
    ->condition('c.nid', $nid)
    ->condition('c.source', $source)
    ->fields('c', array('has_comments'))
    ->execute();
  if ($record->rowCount() == 1) {
    $has_comments[$source][$nid] = ($record->fetchField(0) == 1);
  }

  return $has_comments[$source][$nid];
}

/**
 * Checks if the given content source supports retrieving recent comments.
 *
 * @param string $source
 *   A machine name of a comment source
 *
 * @return bool $supports_recent_comments
 *   Returns TRUE only if the source is available and provides a value for
 *   'supports_recent_comments' that casts to TRUE.
 */
function comment_sources_supports_recent_comments($source) {
  $sources = _comment_sources_sources();
  $result = isset($sources[$source]) ? (bool) $sources[$source]['supports_recent_comments'] : FALSE;
  return $result;
}

/**
 * Gets the most recent comments for a content source and content type.
 *
 * Wrapper function which calls _comment_sources_recent_comments_$source
 * if the function extists.
 *
 * @param string $source
 *   A machine name of a comment source.
 * @param int $count
 *   The maximum number of comments to return.
 *
 * @return array $recent_comments
 */
function comment_sources_recent_comments($source, $count = 10) {
  $recent_comments = array();
  $function_name = "_comment_sources_recent_comments_" . $source;
  if (function_exists($function_name)) {
    $recent_comments = call_user_func_array($function_name, array($count));
  }
  return $recent_comments;
}

/**
 * Implements hook_form_FORM_ID_alter() for node_type_form.
 */
function comment_sources_form_node_type_form_alter(&$form, $form_state, $form_id) {
  // Modifies the node type edit form if type is set and comments enabled.
  if (!isset($form['#node_type']) || !isset($form['comment'])) {
    return;
  }

  $default_source = comment_sources_get_source($form['#node_type']->type);
  if (empty($default_source)) {
    $default_source = 'comment';
  }

  // Overrides the standard comment javascript with our improved version that
  // also handles comment sources.
  $form['comment']['#attached'] = array(
    'js' => array(drupal_get_path('module', 'comment_sources') . '/comment_sources-node-form.js'),
  );

  // Only display the default comment option controls if using Drupal comments.
  foreach ($form['comment'] as & $form_element) {
    if (is_array($form_element) && isset($form_element['#type'])) {
      $form_element['#states'] = array(
        'visible' => array(
          ':input[name="comment_source"]' => array('value' => 'comment'),
        ),
      );
    }
  }

  // Adds comment source options to form.
  $form['comment']['comment_source'] = array(
    '#type' => 'select',
    '#title' => t('Comment source'),
    '#default_value' => $default_source,
    '#options' => _comment_sources_form_options(),
    '#weight' => -20,
  );

  // @todo Test the case where this is an array.
  // Need to find another module that hooks into the submit form.
  if (isset($form['actions']['submit']['#submit']) && is_array($form['actions']['submit']['#submit'])) {
    $form['actions']['submit']['#submit'][] = '_comment_sources_node_type_form_submit';
  }
  else {
    $form['actions']['submit']['#submit'] = array('_comment_sources_node_type_form_submit', 'node_type_form_submit');
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form.
 */
function comment_sources_form_node_form_alter(&$form, $form_state, $form_id) {
  // Hides settings for inappropriate comment types
  $node = $form['#node'];

  $source = comment_sources_get_source($node);
  // Removes the preset name from fb_social sources
  $source = preg_replace('/:.*$/', '', $source);
  //$form['comment_sources_source'] = $source;

  $status = comment_sources_get_status($node);

  // Only displays one comment settings form on the node.
  switch ($source) {
    case 'comment':
      unset($form['comment_settings']['disqus_status']);
      unset($form['comment_settings']['fb_social_status']);
      // Hides the default comment radio form element.
      $form['comment_settings']['comment']['#type'] = 'value';
      // Provides a checkbox to match other comment sources.
      $form['comment_settings']['comment_status'] = array(
        '#type' => 'checkbox',
        '#default_value' => $status,
        '#title' => t('Drupal comments'),
      );
      break;

    case '':
      unset($form['comment_settings']['disqus_status']);
      unset($form['comment_settings']['fb_social_status']);
      unset($form['comment_settings']['comment']);
      $form['comment_settings']['no_comment'] = array(
        '#type' => 'checkbox',
        '#title' => t('No comments'),
        '#default_value' => 1,
        '#disabled' => TRUE,
      );
      break;

    case 'disqus':
      // Don't hide Drupal comment options if there are pre-existing comments.
      // Note if the comments status is 'Hidden',
      // comment_count will always be zero
      if (!isset($node->comment_count) || ($node->comment_count == 0)) {
        unset($form['comment_settings']['comment']);
      }
      unset($form['comment_settings']['fb_social_status']);
      $form['comment_settings']['#access'] = user_access('toggle disqus comments');
      break;

    case 'fb_social':
      // See comment above re: disqus
      if (!isset($node->comment_count) || ($node->comment_count == 0)) {
        unset($form['comment_settings']['comment']);
      }
      unset($form['comment_settings']['disqus_status']);

      // Add node-specific Facebook comment settings, since they the aren't done
      // in the fb_social module
      if (!isset($form['comment_settings'])) {
        $form['comment_settings'] = array(
          '#type' => 'fieldset',
          '#title' => t('Comment settings'),
          '#collapsible' => TRUE,
          '#collapsed' => TRUE,
          '#group' => 'additional_settings',
          '#weight' => 30,
        );
      }
      else {
        if (isset($form['comment_settings']['comment'])) {
          $form['comment_settings']['comment']['#access'] = $form['comment_settings']['#access'];
          $form['comment_settings']['#access'] = TRUE;
        }
      }

      $form['comment_settings']['fb_social_status'] = array(
        '#type' => 'checkbox',
        '#title' => t('Facebook comments'),
        '#description' => t('Users can post comments using Facebook.'),
        '#default_value' => ($status !== FALSE) ? $status : TRUE,
      );
      break;
  }

  $form['#submit'][] = '_comment_sources_node_form_submit';

  // Overrides the standard comment javascript with our improved version that
  // also handles comment sources.
  if (isset($form['comment_settings'])) {
    $form['comment_settings']['#attached'] = array(
      'js' => array(drupal_get_path('module', 'comment_sources') . '/comment_sources-node-form.js'),
    );
  }
}

/**
 * Saves the comment source setting for a content type
 */
function _comment_sources_node_form_submit(&$form, $form_state) {
  $node = $form['node'];
  $source = isset($form['comment_sources_source']) ? $form['comment_sources_source'] : FALSE;
  $data = _comment_sources_get_node_data($form_state, $source);
  comment_sources_record_node_settings($node, $data['source'], $data['status']);
}

/**
 * Prepares the comment source and status for this node form.
 *
 * @todo find correct element paths.
 */
function _comment_sources_get_node_data($form_state, $source) {
  $data = array();

  $values = $form_state['values'];
  if ($source == 'comment' || isset($form_state['values']['comment_status'])) {
    $source = 'comment';
    $status = $form_state['values']['comment_status'];
  }
  else if ($source == 'disqus' || isset($form_state['values']['disqus_status'])) {
    $source = 'disqus';
    $status = $form_state['values']['disqus_status'];
  }
  else if ($source == 'fb_social' || isset($form_state['values']['fb_social_status'])) {
    $source = 'fb_social';
    $status = $form_state['values']['fb_social_status'];
  }
  else {
    $source = '';
    $status = 0;
  }
  $data['source'] = $source;
  $data['status'] = $status;

  return $data;
}

/**
 * Saves the comment source setting for a content type
 */
function _comment_sources_node_type_form_submit(&$form, $form_state) {
  // Ensures we have a nodetype to update settings for.
  if (!isset($form['#node_type']->type)) {
    return;
  }

  // Prepares params for nodetype source setting.
  $type   = $form['#node_type']->type;
  $source = $form['comment']['comment_source']['#value'];
  if (module_exists('vsite')) {
    $vsite = vsite_get_vsite();
  }
  else {
    $vsite = FALSE;
  }
  comment_sources_set_nodetype_source($source, $type, $vsite);
}

/**
 * Builds list of comment source options for a form element.
 */
function _comment_sources_form_options() {
  // Gets all enabled comment sources.
  $sources = comment_sources_enabled_sources();
  // Adds a machine name keyed element for each enabled source.
  $node_options = array();
  foreach ($sources as $key => $value) {
    $node_options[$key] = $value['description'];
  }

  return $node_options;
}

/**
 * Returns an array of current source settings for each node type.
 *
 * Where there are multiple comment sources provided by the same module, the
 * source names will be of the form 'module_name:source_name'.
 *
 * @param string $default_source
 *   What to return for a nodetype if no source is returned.
 *
 * @return array $type_settings
 *   An array containing comment sources keyed by node type
 */
function comment_sources_type_settings($default_source = '') {
  // Returns the stored information if available.
  $type_settings = &drupal_static(__FUNCTION__, array());
  if (!empty($type_settings)) {
    return $type_settings;
  }

  // Otherwise, builds the info array.
  $enabled_sources = comment_sources_enabled_sources();
  // For each enabled source...
  foreach (array_keys($enabled_sources) as $source) {
    // Handles sources like "$module:$plugin" (i.e. fb_social)
    preg_match('/:(.*$)/', $source, $matches);
    $nodetypes_callback = "_comment_sources_load_" . preg_replace('/:.*$/', '', $source);
    // Gets the nodetypes settings from the source-specific callback.
    if (function_exists($nodetypes_callback)) {
      $params = array();
      if (count($matches) > 1) {
        $params[] = $matches[1];
      }
      $nodetypes = call_user_func_array($nodetypes_callback, $params);
      // @todo what if two comment sources both think they are enabled for the
      // same node type?
      foreach ($nodetypes as $nodetype) {
        $type_settings[$nodetype] = $source;
      }
    }
  }

  // Adds the default comment source to any nodetype missing a source.
  foreach (node_type_get_types() as $node_type) {
    if (!array_key_exists($node_type->type, $type_settings)) {
      $type_settings[$node_type->type] = $default_source;
    }
  }

  return $type_settings;
}

/**
 * Gets Disqus node types comment settings.
 *
 * @return array
 *   Node types using Disqus comments
 *
 * @see comment_sources_nodetypes_sources()
 */
function _comment_sources_load_disqus() {
  return variable_get('disqus_nodetypes', array());
}

/**
 * Gets Facebook preset node types comment settings.
 *
 * @return array
 *   Node types using Facebook comments
 *
 * @see comment_sources_nodetypes_sources()
 */
function _comment_sources_load_fb_social($variant = '') {
  $result = array();
  if ($variant && function_exists('fb_social_preset_load')) {
    $preset = fb_social_preset_load($variant);
    $result = $preset->settings['node_types']['types'];
  }
  return $result;
}

/**
 * Gets Drupal node types comment settings
 *
 * @return array
 *   Node types using Drupal core comments.
 *
 * @see comment_sources_nodetypes_sources()
 */
function _comment_sources_load_comment() {
  $result = &drupal_static(__FUNCTION__);
  if (!is_null($result)) {
    return $result;
  }

  $node_types = node_type_get_types();
  $result = array();
  foreach ($node_types as $node_type) {
    $setting = variable_get("comment_" . $node_type->type, COMMENT_NODE_CLOSED);
    if ($setting == COMMENT_NODE_OPEN) {
      $result[$node_type->type] = $node_type->type;
    }
  }
  return $result;
}

/**
 * Saves a node type's current comment source
 *
 * @param array of the new comment sources, keyed by node type
 */
function comment_sources_save_nodetypes_sources($nodetypes_sources) {
  // Flips the $nodetypes_sources array to be keyed by comment source.
  $sources_nodetypes = array();
  foreach ($nodetypes_sources as $nodetype => $source) {
    $sources_nodetypes[$source][$nodetype] = $nodetype;
  }

  // Gets array containing all sources settings.
  $sources = _comment_sources_sources();

  // For each enabled source...
  $enabled_sources = comment_sources_enabled_sources();
  foreach (array_keys($enabled_sources) as $source) {
    preg_match('/:(.*$)/', $source, $matches);
    $source = preg_replace('/:.*$/', '', $source);

    // Prepares the nodetype save callback function.
    if (isset($sources[$source]['save_function'])) {
      $save_nodetype_callback = $sources[$source]['save_function'];
    }
    else {
      $save_nodetype_callback = "_comment_sources_save_" . $source;
    }

    // Invokes the nodetype save callback for this source, if it exists.
    if (function_exists($save_nodetype_callback)) {
      $enabled_nodetypes = isset($sources_nodetypes[$source]) ? $sources_nodetypes[$source] : array();
      $params = array($enabled_nodetypes);
      // Handles comment sources like "$module:$preset".
      if (count($matches) > 1) {
        $preset = $matches[1];
        $params[] = $preset;
      }
      call_user_func_array($save_nodetype_callback, $params);
    }
  }
}

/**
 * Saves the Disqus node types comment settings.
 */
function _comment_sources_save_disqus($enabled_nodetypes) {
  variable_set('disqus_nodetypes', $enabled_nodetypes);
}

/**
 * Saves the Facebook node type comments settings.
 */
function _comment_sources_save_fb_social($enabled_nodetypes, $preset_name = '') {
  if ($preset_name && function_exists('fb_social_preset_load')) {
    $preset = fb_social_preset_load($preset_name);
    $preset->settings['node_types']['types'] = $enabled_nodetypes;
    ctools_export_crud_save($preset->table, $preset);
  }
}

/**
 * Saves the Drupal comments node types comment settings.
 */
function _comment_sources_save_comment($enabled_nodetypes) {
  $node_types = node_type_get_types();
  foreach ($node_types as $node_type) {
    if ($enabled_nodetypes[$node_type->type]) {
      $setting = COMMENT_SOURCES_DRUPAL_ON;
    }
    else {
      $setting = COMMENT_SOURCES_DRUPAL_OFF;
    }
    variable_set("comment_$node_type->type", $setting);
  }
}

/**
 * Gets the most recent Drupal comments for a content type.
 */
function _comment_sources_recent_comments_comment($count) {
  $comments = db_select('comment', 'c')
    ->innerJoin('node', 'n', 'n.nid = c.nid')
    ->addTag('node_access')
    ->fields('c')
    ->condition('c.status', COMMENT_PUBLISHED)
    ->condition('n.status', NODE_PUBLISHED)
    // Additionally order by cid to ensure that comments with the same timestamp
    // are returned in the exact order posted.
    ->orderBy('c.created', 'DESC')
    ->orderBy('c.cid', 'DESC')
    ->range(0, $count)
    ->execute()
    ->fetchAll();

  return $comments ? $comments : array();
}

/**
 * Get the most recent Disqus comments for a content type.
 */
function _comment_sources_recent_comments_disqus($count) {
  $posts = array();

  $user_api_key = variable_get('disqus_userapikey', '');
  if (empty($user_api_key)) {
    watchdog('comment_sources', "User API key required to display recent Disqus comments", array(), WATCHDOG_ERROR);
  }
  else {
    try {
      $disqus = disqus($user_api_key);
      $forums = $disqus->get_forum_list();
      if (count($forums) != 1) {
        watchdog('comment_sources', "More than one Disqus forum returned. Cannot display recent Disqus comments", array(), WATCHDOG_ERROR);
      }
      else {
        $forum_id = $forums[0]->id;
        $forum_api_key = $disqus->get_forum_api_key($forum_id);
        if (empty($forum_api_key)) {
          watchdog('comment_sources', "Could not retrieve forum key to display recent Disqus comments", array(), WATCHDOG_ERROR);
        }
        else {
          $posts = $disqus->get_forum_posts($forum_id, array(
              'forum_api_key' => $forum_api_key,
              'limit' => $count
          ));
        }
      }
    }
    catch (DisqusException $d) {
      watchdog('comment_sources', "Error trying to retrieve comments from Disqus", array(), WATCHDOG_ERROR);
    }
  }
  return $posts;
}

/**
 * Gets the most recent Facebook comments for a content type.
 *
 * @todo
 */
function _comment_sources_recent_comments_fb_social($content_type, $count) {
  return array();
}

/**
 * Implements hook_node_view().
 */
function comment_sources_node_view($node, $view_mode) {
  // Adds javascript for recording comments made in a third-party system
  $source = comment_sources_get_source($node);
  if (!in_array($source, array('comment', ''))) {
    drupal_add_js(array('comment_sources' => array('nid' => $node->nid)), 'setting');
    drupal_add_js(drupal_get_path('module', 'comment_sources') . '/comment_sources.js');
  }
}

/**
 * Implements hook_node_load().
 *
 * For Disqus nodes, checks to see if the comments should be displayed.
 *
 * @todo add @see (where is this used?)
 */
function comment_sources_node_load($nodes, $types) {
  foreach ($nodes as & $node) {
    if (isset($node->disqus)) {
      $node->disqus['status'] = comment_sources_should_display_comments($node, 'disqus');
    }
  }
}

/**
 * Writes has_comments=TRUE to database when a 3rd party comment is added.
 *
 * Triggered by client-side javascript at comment creation.
 */
function comment_sources_record_comment_ajax() {
  $query_data = array(
    'nid' => filter_input(INPUT_GET, 'nid', FILTER_VALIDATE_INT),
    'source' => $_GET['source'],
  );
  if (!empty($query_data['source']) && !empty($query_data['nid'])) {
    $record = db_select('comment_sources_comments', 'c')
      ->condition('c.nid', $query_data['nid'])
      ->condition('c.source', $query_data['source'])
      ->fields('c', array('nid'))
      ->execute();
    $data = array(
      'nid' => $query_data['nid'],
      'source' => $query_data['source'],
      'has_comments' => TRUE,
    );
    if ($record->rowCount() > 0) {
      drupal_write_record('comment_sources_comments', $data, array('nid', 'source'));
    }
    else {
      drupal_write_record('comment_sources_comments', $data);
    }
  }
}

/**
 * Implements hook_fb_social_event_subscribe().
 */
function comment_sources_fb_social_event_subscribe() {
  // Integrates with google analytics.
  return array(
    'FB.Event.subscribe("comment.create", function(response) {',
    'fb_social_track_comments(response);',
    '});',
  );
}

/**
 * Implements hook_node_delete().
 */
function comment_sources_node_delete($node) {
  // Deletes any existing comment sources info for this node.
  db_delete('comment_sources_comments')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_views_api().
 */
function comment_sources_views_api() {
  return array(
    'api' => 3.0,
  );
}

